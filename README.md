# Домашнее задание по курсу веб-разработки

### Описание
В качестве домашнего задания предлагается выполнить проект «Вопросы и Ответы». Этот сервис позволит пользователям Интернета задавать вопросы и получать на них ответы. Возможности комментирования и голосования формируют сообщество и позволяет пользователям активно помогать другим.
# Результат первого домашнего задания
Созданы файлы разметки и стиля -- базовый внешний вид веб-приложения.
### Файлы разметки и файлы стиля
`html`-файлы расположены в директории `public`:
- ask.html -- страница создания вопроса;
- base.html -- "обёртка" всего сайта;
- index.html -- главная страница, список вопросов;
- login.html -- страница входа;
- signup.html -- страница регистрации;
- question.html -- страница отдельного вопроса;
- tag.html -- страница списка вопрос по теме;
- settings.html -- страница настроек аккаунта.
<br>В `static` находятся `css` файлы с именами, соответствующими таким же `html` файлам.

# Результат второго домашнего задания

С помощью фреймворка Django реализовано динамическое изменение страницы (генерация) при разных данных посредством использований шаблонов, а также настроена маршрутизация.<br>
Создана пагинация.
### Django
Сделана следующая структура проекта:
```
ask_pupkin            - директория проекта
    |--- app          - директория приложения (создается командой manage.py startapp)
    |--- ask_pupkin   - библиотеки проекта (будут созданы django-admin.py)
    |--- manage.py    - скрипт управления (будет создан django-admin.py)
    |--- templates    - шаблоны
    |--- static       - статические файлы (JS, CSS, картинки)
    └--- uploads      - файлы загруженные юзером
```
Настроена маршрутизация проекта по разным страницам (`urls.py`)
- cписок новых вопросов (главная страница) (URL = /)
- cписок “лучших” вопросов (URL = /hot/)
- cписок вопросов по тэгу (URL = /tag/blablabla/)
- cтраница одного вопроса со списком ответов (URL = /question/35/)
- форма логина (URL = /login/)
- форма регистрации (URL = /signup/)
- форма создания вопроса (URL = /ask/)

Пагинация была реализована следующим образом:
```python
def paginate(objects_list, request, per_page=5):
    page_num = request.GET.get('page')
        
    p = Paginator(objects_list, per_page)
    try:
        question_page = p.page(page_num)
    except (EmptyPage, PageNotAnInteger, InvalidPage) as e:
        question_page = p.page(1)
        
    return question_page
```
### Данные
Тестовые данные были созданы простым `for` циклом.

# Результат третьего домашнего задания

### База данных
В качестве базы данных был выбран `PostgreSQL` в `Docker`-контейнере. Описание контейнера находится в корне проекта в `Dockerfile`.
### Заполнение БД тестовыми данными
Заполнение базы данных кажется достаточно простой задачей: требуется лишь описать тестовые данные и написать скрипт для их генерации и отправлять каждую сущность в базу данных.<br>
Однако, при попытке реализации данной задачи на любом языке, скорее всего, можно упереться в две проблемы, особенно в случае большого количества тестовых данных ( > 3.000.000 в моём случае):
1. Генерация данных занимает очень много времени, требует больших вычислительных мощностей и занимает очень много оперативной памяти;
2. Даже при достаточно быстрой генерации данных, сами сущности очень медленно добавляются в базу данных.

Эта проблема решается, к примеру, последовательной генерацией сущностей и разбиением данных на части. В контексте этого домашнего задания сущности создавались в таком порядке: пользователи, профили пользователей, тэги, посты, комментарии и лайки к комментариям и постам. Далее каждый тип данных ещё разбивается на куски (по 10.000 элементов, например) и отправляется в базу данных "большими кусками" вместо отправки каждой сущности в базу данных, а сами данные удаляются из оперативной памяти.<br>
Такой подход идеально поддерживает многопоточность, что позволяет в разы ускорить этот процесс.<br>
Ещё одним эффективным решением стало изменение способа генерации лайков пользователей. Вместо генерации лайка по алгоритму случайный пользователь и случайный пост (что приводило к аварийным ситуациям, например, совпадению пользователя и поста, и требовало время), использовалась генерация по пользователю: функция получала "срез" пользователей, проходила по каждому пользователю и создавала ему по 100 лайков на посты и 100 лайков на комментарии (случайные, конечно). Такой способ, даже при использовании случайного выбора постов и комментариев, работал в разы быстрее, потреблял меньше памяти и при этом упрощал обработку ситуации совпадения постов и комментариев.<br> 
Таким образом, удалось сократить время заполнения базы данных (даже без параллелизации) с нескольких часов до около двух минут и понизить потребление оперативной памяти до всего около 400 мегабайт (до этого программа потребляла всю доступную оперативную память и приводила к аварийному завершению системы).
### Отображение данных, сущности и миграции
Сущности были описаны в `app/models.py`, созданы миграции `python3 manage.py makemigrations && python3 manage.py migrate` и реализованы менеджеры для некоторых моделей.<br>
Далее методы менеджеров были использованы в `views.py` и слегка переделаны шаблоны отображения.

# Результат четвертого домашнего задания

## Авторизация
Свёрстаны формы, в шаблонах используется CSRF-токены. Обработаны ситуации пустых полей как на фронт, так и на бекэнде.
Ошибки выводятся для пользователя в случае чего. Не конфидециальные данные (не пароли), не удаляются при ошибках.
Оформление форм не Bootstrap'ом, а собственное.

## Добавление данных
Добавление вопросов `/ask` и добавление комментариев (со скроллингом до нового комментария) `/question/{id}`.
Обработка разных ошибок.
